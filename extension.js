// The module 'vscode' contains the VS Code extensibility API
// Import the module and reference it with the alias vscode in your code below
const vscode = require('vscode');
const request = require("request");
const fs = require('fs')

// this method is called when your extension is activated
// your extension is activated the very first time the command is executed

function doRequest(url) {
	return new Promise(function (resolve, reject) {
		request(url, { json: true }, function (error, res, body) {
			if (!error && res.statusCode === 200) {
				resolve(body);
			} else {
				reject(error);
			}
		});
	});
}

function getHarborAPI() {
	if (vscode.workspace.workspaceFolders !== undefined) {
		let wf = vscode.workspace.workspaceFolders[0].uri.path;
		const harborConfig = wf + '/.harbor'

		if (fs.existsSync(harborConfig)) {
			let config = fs.readFileSync(harborConfig).toString()
			config = config.split("\n")[0]

			const server = config.split("/")[0]
			const repo = config.split("/")[1]
			const name = config.split("/")[2].split(":")[0]
			const tag = config.split("/")[2].split(":")[1]

			return `http://${server}/api/v2.0/projects/${repo}/repositories/${name}/artifacts/${tag}/additions/vulnerabilities`
		}
	}
	return ''
}

/**
 * @param {vscode.ExtensionContext} context
 */
function activate(context) {
	console.log('Congratulations, your extension "vulnerable" is now active!');

	let bar = vscode.window.createStatusBarItem()
	bar.text = 'High Vulnerabilities'
	bar.tooltip = 'There are some high vulnerablities'
	bar.backgroundColor = '#e35f'

	const toggleLink = {
		provideCodeLenses: async function (document, token) {
			bar.hide()

			let result = []
			if (vscode.workspace.workspaceFolders !== undefined) {
				let wf = vscode.workspace.workspaceFolders[0].uri.path;
				const harborAPI = getHarborAPI()

				try {
					if (fs.existsSync(wf + '/go.mod') && harborAPI !=='' ) {
						var resp = await doRequest(harborAPI)
						const body = resp
						const report = body['application/vnd.security.vulnerability.report; version=1.1']
						if (report && report["vulnerabilities"]) {
							for (var k = 0; k < report.vulnerabilities.length; k++) {
								const vul = report.vulnerabilities[k]
								const pkg = vul.package
								if (vul.fix_version !== '') {
									for (let i = 0; i < document.lineCount; i++) {
										let nameAnchor = document.lineAt(i).text
										if (nameAnchor.indexOf(pkg + ' ' + vul.version) !== -1) {
											const range = new vscode.Range(i, 1, i, 10)
											const testcaseLens = new vscode.CodeLens(range, {
												command: 'vulnerable.fix',
												title: 'Upgrade to fix vulnerabilities',
												arguments: [pkg, vul.version, vul.fix_version]
											})
											result.push(testcaseLens)

											bar.command = {
												title: 'Locate vulnerablitities',
												command: 'vulnerable.locate',
												arguments: [pkg, vul.version, range]
											}
											bar.show()
										}
									}
								}
							}
						}
					}
				} catch (err) {
					console.error(err)
				}
			}

			return result
		},
		resolveCodeLens: function (code, token) {
			return code
		}
	}

	const codeLens = vscode.languages.registerCodeLensProvider({ language: 'go.mod', scheme: 'file' }, toggleLink)
	context.subscriptions.push(codeLens)

	let vulnerableLocate = vscode.commands.registerCommand('vulnerable.locate', (pkg, version, selection) => {
		if (vscode.workspace.workspaceFolders !== undefined) {
			let wf = vscode.workspace.workspaceFolders[0].uri.path;
			vscode.workspace.openTextDocument(wf + '/go.mod').then(
				document => {
					vscode.window.showTextDocument(document, {selection: selection})
				}
			)
		}
	})

	let vulnerableFix = vscode.commands.registerCommand('vulnerable.fix', function (pkg, version, fix_version) {
		if (vscode.workspace.workspaceFolders !== undefined) {
			let wf = vscode.workspace.workspaceFolders[0].uri.path;

			try {
				if (fs.existsSync(wf + '/go.mod')) {
					const data = fs.readFileSync(wf + '/go.mod')
					const result = data.toString().replace(pkg + ' ' + version, pkg + ' ' + fix_version)

					fs.writeFileSync(wf + "/go.mod", result)
				}
			} catch (err) {
				console.error(err)
			}
		}
	})

	context.subscriptions.push(vulnerableFix, vulnerableLocate);
}

// this method is called when your extension is deactivated
function deactivate() { }

module.exports = {
	activate,
	deactivate
}
